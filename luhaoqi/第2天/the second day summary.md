1五种IPC的使用
	1.1信号量：给临界资源建立一个标志用于表示临界资源被占用情况，实现线程间的同步或临界济源的互斥访问。
		信号量创建函数：rt_sem_t rt_sem_create(const char *name,//信号量名字
												rt_uint32_t value, //信号量初始值
												rt_uint8_t flag)//信号量模式（RT_IPC_FLAG_FIFO：由优先级高的线程优先获得资源
																			  RT_IPC_FLAG_PRIO：按照先来先得的顺序获得资源）
		信号量的获取：rt_err_t rt_sem_take(rt_sem_t sem, 
											rt_int32_t timeout)//设置等待时间，在时间到时恢复线程，如果是RT_WAITING_FOREVER（value=-1），则一直等待直至获取到信号量
		信号量的释放：rt_err_t rt_sem_release(rt_sem_t sem)
		信号量的删除：rt_err_t rt_sem_delete(rt_sem_t sem)
	
	1.2互斥锁：现在有3个线程分别为H线程（High）、M线程（Middle）、L线程（Low），3个线程的优先级顺序为H线程>M线程>L线程。假设系统中有一个资源被保护了，此时该资源被L线程正在使用中，
				某一刻，H线程需要使用该资源，但是L线程还没使用完，H线程则因为申请不到资源而进入阻塞态，L线程继续使用该资源，此时已经出现了“优先级翻转”现象，高优先级线程在等着低优先级的线程执行，
				如果在 L 线程执行的时候刚好M线程被唤醒了，由于M线程优先级比L线程优先级高，那么会打断L线程，抢占了CPU的使用权，直到M线程执行完，再把CUP使用权归还给L线程，L线程继续执行，
				等到执行完毕之后释放该资源，H线程此时才从阻塞态解除，使用该资源。
				而互斥量通过优先级继承的方法，即当高优先级H线程获取低优先级L线程正在使用的互斥量而被挂起后，低优先级L线程暂时继承H线程的优先级，这时当优先级处于L与H线程的M线程被唤醒后，就无法打断此时继承了高优先级的L线程，有效解决了优先级反转问题。
	
	1.3邮箱：一种异步通信方式，主要用于数据的上下文的切换，将数据从A线程发送给B线程，或者中断中发送给B线程，不涉及数据的拷贝，一条消息固定4字节，发送消息会引起系统的调度
	
	1.4队列信号：消息队列是另一种常用的线程间通讯方式，它能够接收来自线程或中断服务例程中不固定长度的消息， 并把消息缓存在自己的内存空间中。其他线程也能够从消息队列中读取相应的消息，
				而当消息队列是 空的时候，可以挂起读取线程。当有新的消息到达时，挂起的线程将被唤醒以接收并处理消息。消息 队列是一种异步的通信方式。
				消息队列可以应用于发送不定长消息的场合，包括线程与线程间的消息交换，以及中断服务例程中 发送给线程的消息（中断服务例程不可能接收消息）。 

	1.5事件：主要用于线程间的同步，与信号量不同，它的特点是可以实现一对多，多对多的同步。 事件另外一个特性是，接收线程可等待多种事件，即多个事件对应一个线程或多个线程。 
			同时按照线程等待的参数，可选择是 “逻辑或” 触发还是 “逻辑与” 触发。
			RT-Thread 定义的事件有以下特点：
			•事件只与线程相关，事件间相互独立：每个线程拥有 32 个事件标志，采用一个 32 bit 无符号整型数进行记录，每一个 bit 代表一个事件。若干个事件构成一个事件集；
			•事件仅用于同步，不提供数据传输功能；
			•事件无排队性，即多次向线程发送同一事件 (如果线程还未来得及读走)，其效果等同于只 发送一次。 

2内存管理
	2.1内存池管理
		2.1.1 void* rt_mp_alloc  ( rt_mp_t  mp,  //内存池对象
								  rt_int32_t  time  //超时时间
								) 
								该函数将从指定的内存池中分配一个内存块，如果内存池中有可用的内存块，则从内存池的空闲块链表上取下一个内存块，减少空闲块数目并返回这个内存块；
								如果内存池中已经没有空闲内存块，则判断超时时间设置：若超时时间设置为零，则立刻返回空内存块；若等待时间大于零，则把当前线程挂起在该内存池对象上，
								直到内存池中有可用的自由内存块， 或等待时间到达。
		2.1.2 void rt_mp_free  ( void *  block ) 
								任何内存块使用完后都必须被释放，否则会造成内存泄露。调用该函数释放指定的内存块， 首先通过需要被释放的内存块指针计算出该内存块所在的（或所属于的）内存池对象，
								然后增加内存池对象的可用内存块数目，并把该被释放的内存块加入空闲内存块链表上。 接着判断该内存池对象上是否有挂起的线程，如果有，则唤醒挂起线程链表上的首线程。
	2.2动态内存管理	
		2.2.1 void* rt_malloc  ( rt_size_t  size ) //该函数将从内存堆上分配用户指定大小的内存块。

		2.2.2 void rt_free  ( void *  rmem ) //用户线程使用完从内存分配器中申请的内存后，必须及时调用该函数释放，否则会造成内存泄漏， 系统会把待释放的内存还回给堆管理器中。